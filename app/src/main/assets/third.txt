В некоторых случаях часть программы на языке высокого уровня удобнее записать непосредственно на языке ассемблера, например, для доступа к ресурсам операционной системы, ускорения работы критичного по времени выполнения участка программы и т.д. Например, в языке программирования C++ для этой цели служат внешние подпрограммы, объявляемые в разделе описания процедур и функций следующим образом:

------------------------------
extern "C" {
	int myFunc(int a, int b) {
		return a + b;
	}
}
------------------------------

Заголовки описаний внешних подпрограмм составляются по обычным правилам, c добавлением ключевого слова extern. По заголовкам транслятор проверяет соответствие типов параметров и генерирует код для вызова подпрограмм. Перед объявлением внешней подпрограммы необходимо указать с помощью директивы компилятора, в каком файле находится ее объектный код. Например, если объектный код размещается в файле myFunc.obj, следует использовать соответствующую настройку компилятора. Для этого в исполняемом файле необходимо сделать следующее:

tdlink main.obj myFunc.obj

Для того, чтобы получить файл myFunc.obj, необходимо скомпилировать C++ файл.


Можно записать несколько ключей, если подпрограммы размещаются в разных файлах. Причем не является обязательным построение объектного кода только транслятором с языка ассемблера. Через внешние подпрограммы С++ допускает возможность связи с подпрограммами на любом языке программирования, если его транслятор создает объектный файл и поддерживает приводимый далее способ передачи параметров подпрограмм.

C++ имеет несколько встроенных типов данных, включая char, int, float, double, bool, а также разные модификаторы, такие как short, long и указатели - pointer.

Переменные перечисленных выше типов могут быть параметрами внешних подпрограмм или результатами внешних функций. C++ весьма гибок в использовании типов данных: вы можете передавать различные пользовательские типы и структуры в качестве параметров функций. Однако важно помнить, что не все типы данных могут быть возвращены из функций.

В ходе работы с символьными данными часто используется тип string, в формате которого нулевой байт является динамической (реальной) длиной строки, в последующих байтах находятся символы строки. Статическая длина зависит от объявления, но не больше 255 символов.


В C++ параметры функций можно передать несколькими способами: параметр-значение, параметр по ссылке, параметр-указатель.

Формальный параметр-значение считается локальной переменной подпрограммы с той разницей, что его инициализация выполняется вне подпрограммы перед ее вызовом. Изменение такого параметра внутри подпрограммы не оказывает влияния на соответствующий фактический параметр. Если фактический параметр задан в виде выражения, то перед вызовом подпрограммы оно вычисляется. 

Пример:

------------------------------
void f1(int a) {
	a += 1; //изменения не затрагивают исходное значение
}
------------------------------

Параметр-ссылка используется, когда необходимо изменить фактический параметр, передавая его адрес. Это позволяет функции изменять оригинальное значение, поскольку изменения, сделанные с параметром-ссылкой, также отразятся на фактическом параметре. При объявлении параметра-ссылки используется символ &.

Пример:

------------------------------
void f1(int &a) {
	a += 1; //изменения затрагивают исходное значение
}
------------------------------

Параметры могут также передаваться через указатели. Это позволяет передать адрес фактического параметра, что также позволяет функции изменять его значение. Указатели требуют явной проверки, что они не равны nullptr.

Пример: 

------------------------------
void f1(int *p) {
	if (p) {
		*p += 10; //изменения затрагивают исходное значение
	}
}
------------------------------

Фактические параметры всегда передаются подпрограмме через стек в порядке их перечисления в заголовке. Если размер параметра – один байт, то он расширяется до слова, старший байт которого неопределен. Для параметров длиной в двойное слово старшее слово помещается в стек перед младшим. 


Рассмотрим пример заголовка подпрограммы и организации передачи их параметров:

Шаг 1. Имеем следующую подпрограмму на языке C++:

------------------------------
extern "C" void sum(long a, long& b, bool c) {
    b = a + 10;
}
------------------------------


Шаг 2. Формирование параметров:

------------------------------
data segment
	a dd 0 ; Хранение значения a
	b dd 0 ; Хранение значения b
	c db 1 ; логическая переменная (true)
data ends
code segment
extern sum

start:
	; Инициализация а
	mov eax, 1 ; старшее слово
	shl eax, 16 ; сдвиг влево
	or eax, 2  ; младшее слово
	mov a, eax ; сохраняем в а

	mov al, c

	; Передаем параметры на стек
	push a	; параметр а
	push offset b ; адрес b
	push eax ; параметр с
	
	call sum

	; Завершение программы
	mov ax, 4C00h
	int 21h

code ends
end start
------------------------------


Результат функции возвращается в регистрах процессора: байты – в регистре аl, слова – в регистре ах, двойные – слова в паре регистров ax_dx (старшее слово – в dx, млад-шее – ах). Если результат функции указатель, то dx – сегмент, а ах – смещение. Для функций с результатом типа string резервируется место под результат, а его адрес пере-дается в качестве первого параметра. Функция не должна изменять этот параметр и удалять его из стека после окончания работы.

Требуемые подпрограмме локальные переменные можно размещать в стеке, сегменте данных или сегменте кода. Однако C++ имеет некоторые ограничения на способ определения переменных в сегменте данных, поэтому рекомендуется этот сегмент не использовать. 


Специальный вид подпрограмм представляют рекурсивные подпрограммы, т.е. подпрограммы, вызывающие сами себя. Различают два типа рекурсии: прямая, когда подпрограмма содержит вызов самой себя непосредственно в ее теле; косвенная, когда подпрограмма вызывается одной из вызываемых ею программ. Тип рекурсии практически не влияет на реализацию кода подпрограммы.

Не каждый язык программирования допускает написание рекурсивных программ: возможность рекурсивного вызова обеспечивают языки, использующие динамическое распределение памяти под локальные переменные. Традиционно локальные переменные размещаются в сегменте стека, поэтому каждый прямой рекурсивный вызов приводит к порождению одинаковой по размеру области стека (фрагмент стека), отличающийся от предыдущей значениями фактических параметров и адресом выхода:

ss:sp
 _______________________________________
|                |                          |                          |
| Адрес    | Локальные    | Фактические |
| выхода  | переменные | параметры     |
|_________|______________|_______________|

При косвенном вызове происходит перемешивание фрагментов стека подпрограмм, встречающихся в цепи вызова. Количество фрагментов стека, порождаемых в процессе рекурсивных вызовов, называют глубиной рекурсии, а максимально возможное количество фрагментов в доступной части сегмента стека – глубиной стека.


Для построения кода рекурсивной подпрограммы используется приведенная выше схема. Учитывается лишь необходимость формирования в теле подпрограммы параметров ее рекурсивного вызова по обычным правилам. Проиллюстрируем сказанное реализацией кода рекурсивной функции вычисления факториала целого числа (ошибки переполнения не контролируются), специально дополненной ненужной в алгоритме локальной переменной Х и операторами над ней:

Шаг 1: Реализация внешней подпрограммы на языке С++

------------------------------
extern "C" {
    int Fact(int I) {
        if (I <= 1) {
            return 1; // базовый случай
        } else {
            return Fact(I - 1) * I; // рекурсивный вызов
        }
    }
}
------------------------------


Шаг 2: Формирование параметров

------------------------------
data segment
    prompt db 'Введите целое число: $'
    result_msg db 'Факториал: $'
    input db ?           ; Хранение входного числа
    output dw ?          ; Хранение результата
    newline db 13, 10, '$'
data ends

code segment
extern Fact:proc         ; Внешняя функция

    ; Инициализация сегмента данных
    mov ax, @data
    mov ds, ax

    ; Выводим приглашение
    lea dx, prompt
    mov ah, 09h
    int 21h

    ; Читаем число (ввод)
    mov ah, 01h
    int 21h
    sub al, '0'          ; Преобразование ASCII в число
    mov input, al       ; Сохраняем входное число в input

    ; Вызываем внешнюю функцию Fact
    mov al, input
    call Fact           ; Получаем результат в AL
    mov output, ax      ; Сохраняем результат из AX

    ; Печатаем результат
    lea dx, result_msg
    mov ah, 09h
    int 21h

    mov ax, output      ; Подготовим вывод
    ; Подготовим для вывода
    add ax, '0'         ; Преобразование в ASCII
    mov dl, al          ; Помещаем результат в DL
    mov ah, 02h
    int 21h             ; Выводим результат

    ; Печатаем новую строку
    lea dx, newline
    mov ah, 09h
    int 21h

    ; Завершение программы
    mov ax, 4C00h
    int 21h
code ends
end main
------------------------------


Проектирование рекурсивных подпрограмм должно сопровождаться оценкой глубины стека и правильным составлением условия окончания рекурсии. Ошибки при оценке этих параметров приводят к переполнению стека. Обычно подпрограмме выделяется только часть от общего сегмента стека, но, если предполагается большая глубина рекурсии либо подпрограмме требуется много места под локальные переменные, то необходимо позаботиться о переключении сегмента стека путем изменения регистра ss. Такие проблемы возникают и при рекурсивном программировании на языках высокого уровня, но доступ к управлению распределением памяти там обычно ограничен, и в качестве промежуточного решения можно рекомендовать вынесение локальных переменных из подпрограммы и уменьшение количества ее параметров.
 
Это несколько сокращает затраты стека, но не всегда решает проблему.


В ходе написания внешних подпрограмм для C++ необходимо соблюдать соглашение о сохранении регистров bp, sp, ss и ds при выходе из подпрограммы. Несоблюдение соглашения приведет к нарушению работы оперaционной системы. Все остальные регистры можно изменять.

В общем случае внешняя ассемблерная подпрограмма включает:
– механизмы доступа к параметрам и возврата результатов;
– реализацию кода подпрограммы с учетом необходимоcти сохранения значений некоторых регистров;
– механизмы распределения памяти под локальные переменные и выхода из подпрограммы с удалением динамически распределяемых переменных и параметров;
– описание точки входа в подпрограмму с помощью псевдооператора public, что делает возможным обращение к подпрограмме из других модулей путем объявления ее имени в псевдооператоре extrn.

Правила оформления модуля с внешней подпрограммой не отличаются от применяемых при написании текста обычной программы с той разницей, что в псевдооператоре end не должна указываться метка точки входа.

